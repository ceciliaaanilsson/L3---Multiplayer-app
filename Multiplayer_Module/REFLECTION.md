## Assignment Report

### Naming
| Name and explanation | Reflection |
|----------------------|------------|
|**GameClient** - Class name in the module | **Avoid disinformation**: GameClient isn’t directly disinformation, but the name isn’t specific enough about what the class actually does. A more specific name could have been chosen since GameClient doesn’t provide much more information beyond the fact that it handles the game’s client. At the same time, I think it’s a good name because the intention of the module is for it to be used in a game, and everything the client handles happens there.|
|**GameCharacter** - Class name in the module| **Add meaningful context**: The class name tells you exactly what it does, but it gives too little information. My intention with GameCharacter is that it should be extended, and you should be able to create a custom game character, which is not apparent from the name. The user won’t think of that when they first see the name but will only realize it later when reading the documentation. A better name could have been something like ‘BaseCharacter’ or ‘BasePlayer’.|
|**setupWebsocket()** - Method in GameClient|**Use Intention-Revealing Names**: A method name should clearly convey what the method does. The name **setupWebsocket()** reveals that something related to WebSockets is being set up, but it’s not descriptive enough. It doesn’t provide any information about what exactly is being “set up”—whether it’s creating a connection, configuring a specific WebSocket instance, or setting up communication channels. **Avoid Disinformation**: The name **setupWebsocket()** could create false expectations. The word “setup” is too general and could suggest different things to different developers—whether it’s starting a server or creating a WebSocket instance. This can mislead other developers about the exact nature of the “setup,” which goes against the principle of avoiding misleading names. A more specific name describing exactly what is being set up would be more appropriate. |
|**handleMovement()** - Method in GameClient | **Use intention-revealing names**: The user knows that the method handles movement, but nothing beyond that. The method name should be more descriptive, providing the user with more information. **Avoid disinformation**: When the user doesn’t get more information than that the method handles movement, it becomes misleading. The user of the class will start to speculate about what kind of movement the method is supposed to handle, witch the user should not have to do.|
|**GameServer** - Class name in the module | **Don't be cute**: **GameServer** is not actually a GameServer. It’s a WebSocket server. There’s not much in the class that directly connects it to a game, so it shouldn’t be named as such. It creates a WebSocket server that clients can connect to, which isn’t apparent from the name. I thought the name was appropriate at the time when the intention was to create a game module, but after further thought, descriptive names carry more weight. **Avoid disinformation**: Calling the class **GameServer** is downright misleading. It’s not a game server, so there’s no reason it should be named that.|

### Reflection on naming:
Initially, I believed that the naming of my classes and methods was adequate, but reading Clean Code has made me reconsider. I now realize that naming is more than just a way to label code—it’s a powerful form of communication between developers. Good naming can make the code more intuitive, readable, and easier to maintain, while poor naming can obscure its meaning and lead to misunderstandings. One of the main points Clean Code highlights is that names should be intention-revealing. When a name clearly conveys the purpose of a variable, method, or class, it reduces the cognitive load on developers. They shouldn’t need to look at the implementation details to understand what a piece of code does; the name should make it clear. For example, names like setupWebsocket() and handleMovement() in my code are too vague. These names don’t provide enough context, forcing the reader to make assumptions about their functionality. After reflecting on this, I realize that more descriptive names would have prevented confusion and speculation about the purpose of these methods. Moreover, I also see how vague or overly generic names can be misleading, as illustrated by my choice of GameServer. The name gave the impression that it was a general game server, but in reality, it was a WebSocket server. Using descriptive names such as WebSocketServer would have more accurately conveyed the class’s role, avoiding disinformation. It’s easy to fall into the trap of giving classes or methods “catchy” names without thinking about their actual function, but doing so can mislead others who may interact with the code in the future.

### Functions

|Functions | Rows | Reflection|
|----------|------|-----------|
|**handleMessage(event)** - method in GameClient| 25 | **Small!**: The method does not follow the clean code standard. This method is far to big. **Do one thing**: The method do not do one thing. The method uses statements to choose witch action that should happend and all those actions could be their own methods. **Don't repeat yourself**: The method also repeats itesel (DRY!). We could easily make a method for checking if a player is not on the list, create a new one!|
|**handleMovement(player)** - A method in GameClient | 28 | **Small!**: This method is also far to big. There is also an function in the method that could easily be a seperate method. **Do one thing**: The method does not do one thing. As I said in the reflection above, the method has a function. That tells me it does more than one thing.|
|**handleMessage(ws, data)** - Method in GameServer| 24 | **Function arguments**: Clean code tells us that the best methods have zero arguments but I do not know if I agree. It is easier in a way that we do not have to figure out what the argument or arguments is. It also makes the methods easier to use in a way because we dont have ta pass any data to that method. When using arguments in a method it will make it mor customizable sometimes. In my method, it is necessary to use this methodbecause of the websocket- and data object.|
|**handleConnections(ws)** - Method in GameServer | 18 | **Use descriptive names**: The name handleConnections() gives a general idea that the method is responsible for managing some kind of connections, but it doesn’t specify what type of connections are being handled. Is it handling incoming client connections? Is it managing reconnections, disconnections, or multiple WebSocket connections? Without this specificity, the developer or reader has to dive into the method’s implementation to understand its exact purpose.|
|**setupWebsocket(player)** - Method in GameClient | 15 | **Use descriptive names**: The name setupWebsocket() is too vague and does not clearly convey what the method is doing. It tells us that something is being set up related to WebSockets, but it doesn’t specify what is being set up or how. Does this method establish a WebSocket connection? Does it configure WebSocket settings for the player? Or perhaps it initializes communication channels between the player and the server? **Section within functions**: Upon examining the structure of the method, it becomes clear from the indents, whitespace, and the length of the method that it’s doing more than one thing. Long methods with deep nesting often indicate that the function is handling multiple responsibilities, violating the Single Responsibility Principle.|

### Reflection on functions:
After reviewing my functions and comparing them to Clean Code principles, it’s clear that many of them don’t meet the standards of good function design, particularly when it comes to size, responsibility, and argument handling.

I believe Clean Code offers valuable insights into how to write better, more understandable code. It fundamentally changes the way we think about communication through code, pushing us to write code that is self-explanatory and clear for others (and ourselves) to read and maintain. However, I don’t fully agree with every guideline in the book. For example, while Clean Code suggests that the indent level should be kept to one or two levels deep to avoid complexity, I believe there are situations where deeper indentation can be acceptable. In some cases, complex logic requires more nesting, and reducing it might result in code that’s less intuitive or broken into unnecessarily small pieces.

The key is finding a balance—keeping the code as simple as possible without sacrificing clarity or structure. Deeply nested code can sometimes be managed well if it remains readable and maintains a clear flow.

### Reflection

The book Clean Code provides invaluable insights into writing more understandable, maintainable, and efficient code. It encourages us to shift our mindset towards thinking of code as a form of communication between developers, rather than just instructions for the computer to execute. After applying these principles to my own code, I realize there are several areas where my approach falls short, particularly in terms of naming conventions, function design, and method size.

One of the key takeaways from Clean Code is the importance of naming. Before, I believed that as long as a name was somewhat descriptive, it was enough. However, the book emphasizes that names should be intention-revealing and highly specific, which improves code readability and reduces confusion. In my reflections, I noted how names like setupWebsocket() or handleMovement() are too vague and don’t provide enough information about what the method is actually doing. This forces other developers to dive into the method to understand its purpose, which is exactly what Clean Code advises against. More descriptive names, such as initializeWebsocketConnection() or processPlayerMovement(), would have immediately clarified the intent of these methods.

Similarly, I now see that method sizes in my project are often too large. The principle of Do One Thing from Clean Code suggests that each method should be responsible for a single task. Several of my methods, like handleMessage() and handleMovement(), violate this principle by trying to do too much. Breaking these large methods down into smaller, more focused methods would not only make the code easier to understand but also enhance reusability and maintainability.

I think it has been nice to follow some guidelines on writing code. I feel that this book will help me on my journey to becoming a developer and communicate with my code. Although I think you should take the book with a grain of salt.